# UnicodeとUTF-8

- ASCIIコードだけでは日本語や他の言語の文字を表現できないので、かつては言語ごとに文字コードが考案され使われてきた
- しかし、これでは、ある言語のある文字が別の言語の文字と同じバイナリで表現されるということがあり、2つ以上の言語を同じテキストファイルに混在させることができなかった
- これを解決するために決められたUnicodeは、全言語の各文字に固有の番号を与えた文字コードの企画
- Unicodeでは英字でない言語のアルファベットや漢字、ひらがな、カタカナ、アラビア文字など世界中で使われている文字に128番以降の番号が付けられ、番号で互いに識別できるようになっている
- Unicodeの最初の127番目までは、ASCIIコードと同じ文字が割り当てられている

```bash
echo "媛という感じで表すとUnicodeとUTF-8で異なる値になる"
echo -e '\U5A9B' '\xE5\xAA\x9B'


echo "zの場合は同じ"
echo -e '\U5A' '\x5A'


# 媛という感じで表すとUnicodeとUTF-8で異なる値になる
# 媛 媛
# zの場合は同じ
# Z Z
```

- 16進数の`0x5A(Z)`,`0x5A9B(媛:unicode)`,`0xE5AA9B(媛:UTF-8)`を2進数に変換する

```bash

echo "まずは2進数に変換"
echo 5A 5A9B E5AA9B |
    xargs -n 1 |
    sed '1 iibase=16;obase=2' |
    bc |
    xargs printf "%24s\n" |
    sed -r 's/.{8}/& /g'

# まずは2進数に変換
#                    1011010
#           1011010 10011011
# 11100101 10101010 10011011
```

- 2進数を見ても、元の16進数をみても、ZとUnicodeの「媛」の上の1バイトが共通している
- 2進数では1011010(1バイトに直すと01011010)が共通
- これではテキストファイルを先頭から1バイトずつ読んでいって`01011010`が出てきたら「Z」なのか「媛」なのか判断できない
  - 媛の場合はその次のバイトを読めばZでないとわかるかもしれないが、「Z + 10011011から始まる別の字」の可能性もある
  - 1011010 10011011の後ろにまだ続きがあって、それが別の文字を表してるかもしれない
- 一方、UTF-8の方は全ての8桁の2進数で1番上の桁が1になっている
- これは、UTF-8では1バイトで表せる文字は1バイト目の先頭が0になっているから
- つまりUTF-8の「媛」のバイトの並びには、ASCIIコードのものが出現しない
- **UTF-8は、バイト列のASCIIコードに相当する部分とそれ以外の部分を、8ビットの1番上の桁で見分けられるようになっている**

## 符号化文字集合と文字符号化形式/方式

- テキストの表現にはUnicodeの番号体型の他に、その番号を何ビットで表現するかなど、他のことも決めないといけないということ
- 各文字の番号をどういうビット列で記録するかを決めた`文字符号化形式`と文字列(文章)をどのようにファイルの中に並べるかを決めた`文字符号化方式`が必要になる
- 文字に番号をつけただけのものは`符号化文字集合`と呼ばれる

## 固定長 v.s. 可変長

- UTF-8では1文字に割り当てるデータの長さが可変になる
- 一方、Unicodeの符号化方式にはUTF-16やUTF-32が存在し、これらは1文字をそれぞれ16ビット、32ビットの固定長で表現する
- 固定長なので、Unicodeの番号を単純に2進数にして頭をゼロで埋めたものが、文字の記録に使用される
- 固定長のUTF-16やUTF-32の方は単純明快だが、LinuxではUTF-8が標準
- 既存のtrなどのcommandがUTF-8前提で作られている
  - `tr -d a`とやればテキストデータがUTF-8ならばどんな文字が混ざっていてもa(16進数で0x61)だけを削除してくれる
  - しかし、UTF-16やUTF-32の場合は、1文字を16ビットや32ビットで表現しているので、1バイト単位で削除することができない

---

# 文字コードと改行記号の変換

- Shift_JISをUTF-8に変換する

- 0x0dはasciiで調べると「CR」という文字
  - CRはキャリッジリターンの略で、古いタイプライターの時代には、
    カーソルを一番左に戻すために使われていた文字
  - 今でも、改行コードとして使われている
  - windowsではキャリッジリターンとラインフィードの組み合わせで改行を表す(CRLF)

## nkfのオプション

- shift_jisの文章をUTF-8にするときに、半角カタカナをそのままにして改行コードをLFにしたければ、`nkf -wLux`というオプションをつければ良い
  - これがWindows用からLinux用にテキストファイルを変換するときの標準的なnkfの用法になる

## iconv

- 文字コードの変換には、nkfの他にicovというコマンドがよく使われる
