# 別のシェルにシグナルを飛ばす
- `ctrl + s`を押すと、操作中のシェルが出力を止めて、固まっているように見える状態になる
    - `ctrl + q`を押すと、固まっていたシェルが再開する
- ロック状態を発生させる
```bash
root@9925e06ab091:/# echo $$
# 8
root@9925e06ab091:/# kill -s 19 $$
```

- 19 SIGSTOP プロセスの一時停止 (stop)
- 18 SIGCONT 一時停止 (stop) からの再開
- 調べ方
```bash
kill -l | grep 19
```

- `kill -s 19 $$`で自身のシェルを一時停止させる
- `kill -s 18 $$`で自身のシェルを再開させる

- プロセスIDを使わず、`pkill`を使う方法もある
```bash
pkill -SIGCONT bash
```
- `pkill`はプロセス名からシェルのプロセスを特定し、`SIGCONT`を発行する
- 停止していないシェルに対して**SIGCONT**シグナルを送ったとしても問題が発生することはない


# exit時にファイルを消す
- 今操作している端末を閉じたときに、自身のホーム下のtmpディレクトリのファイルを消す仕掛けを作る
- **trap**では発生したシグナルに応じて処理を実行させることができる
    - **EXIT**を指定することでターミナル終了時の処理を仕込める
```bash
trap 'rm -rf /tmp/*' EXIT
```
- シバン(#!/bin/bashのような表記)の下あたりに書いておくと、シグナルを受けて以上終了するときに、シェルスクリプトが後始末するようになる

- sshでログインしたときなど、使用しているシェルがログインシェルの場合、trapを使わなくても、Bashの設定ファイルである`~/.bash_logout`にログアウト時の処理を仕込める
- ログインシェル
    - ログインして最初に動き出すshell
        - https://wa3.i-3-i.info/word11274.html

```bash

echo  'rm ~/tmp/*' >> ~/.bash_logout

``` 

